Purpose:

The repository acts as a bridge between the data layer (model and webservice) and the view models.
It abstracts the data sources and provides a clean API for the rest of the app to interact with the data.
It handles network operations, database access and API calls to provide data to view models.

What to include:

* Classes handling data fetching from network or local databases
* Functions like get(), delete(), update() that provide data to the view models
* Data manipulation logic

Examples:

* UserRepository.kt
* inventoryRepository.kt

== Example [InventoryRepository.kt]
    // imports: Uses coroutines, "model/" objects, "data" and "webservice" for databases or apis.
    class InventoryRepository(val context: Context){

        private var inventoryDao:InventoryDao = InventoryDB.getDatabase(context).inventoryDao()
        private var apiService: ApiService = ApiUtils.getApiService()

         suspend fun saveInventory(inventory:Inventory){
             withContext(Dispatchers.IO){
                 inventoryDao.saveInventory(inventory)
             }
         }
        suspend fun getListInventory():MutableList<Inventory>{
            return withContext(Dispatchers.IO){
                inventoryDao.getListInventory()
            }
        }
        suspend fun deleteInventory(inventory: Inventory){
            withContext(Dispatchers.IO){
                inventoryDao.deleteInventory(inventory)
            }
        }
        suspend fun updateRepositoy(inventory: Inventory){
            withContext(Dispatchers.IO){
                inventoryDao.updateInventory(inventory)
            }
        }
        suspend fun getProducts(): MutableList<Product> {
            return withContext(Dispatchers.IO) {
                try {
                    val response = apiService.getProducts()
                    response
                } catch (e: Exception) {

                    e.printStackTrace()
                    mutableListOf()
                }
            }
        }
    }